---
title: Svelte
description: Integrate wuchale with Svelte - extract translations from Svelte components, manage locale catalogs, and implement efficient loading strategies for both SvelteKit and SPA.
---

Import | `import { adapter } from "@wuchale/svelte"`
-|-
Loader extensions | `.svelte.js`, `.svelte.ts`, `.js`, `.ts`
Default `files` | `src/**/*.svelte`, `src/**/*.svelte.{js,ts}`
Available loaders | `svelte`, `sveltekit`
Compatibility | Svelte >= 5

## Setup in Your App

Svelte applications may or may not use SvelteKit and that makes the loading of
the compiled catalogs a bit different. The Svelte adapter tries to detect
whether SvelteKit is in use and write the suitable default loader. Assuming it
was correct, follow the following steps. If it was wrong, edit the loader file
first.

### Svelte (SPA)

You can use one of the two approaches mentioned in [placeholders](/guides/placeholders).

import { Steps, Tabs, TabItem } from '@astrojs/starlight/components';

<Tabs>
    <TabItem label="Loading message">
        ```svelte
        <!-- src/App.svelte -->
        <script>
          import { loadLocale } from 'wuchale/load-utils'
          // so that the loaders are registered first
          import './locales/main.loader.svelte.js'
          // you can use any state from anywhere for the locale
          let locale = $state('en')
        </script>

        {#await loadLocale(locale)}
            <!-- Ignored because it is rendered before the catalog is loaded -->
            <!-- @wc-ignore -->
            Loading translations...
        {:then}
            <!-- Your app content -->
        {/await}
        ```
    </TabItem>
    <TabItem label="Placeholder messages">
        ```svelte
        <!-- src/App.svelte -->
        <script>
          import { loadLocale } from 'wuchale/load-utils'
          // so that the loaders are registered first
          import './locales/main.loader.svelte.js'
          // you can use any state from anywhere for the locale
          let locale = $state('en')
          $effect(() => {
              loadLocale(locale)
          })
        </script>

        <!-- Your app content -->
        ```
    </TabItem>
</Tabs>

### SvelteKit (SSR/SSG)

If you use SvelteKit for just a client only app, you can use the above setup
for Svelte. This is for when you need SSR.

The SvelteKit setup has two layers (server and client) and the loader file has
to account for both. The default loader can be seen as an example.

#### SSR

When rendering on the server, the above setup for Svelte can't work because it
uses a global state and using global states on the server is a bad idea, as it
can leak information (in our case the current locale) between requests, because
requests share the global state. To deal with this, a separate loader file is
generated and a separate utility is provided that can isolate the locale state
per request. You can set it up inside `hooks.server.{js,ts}`.

```js
// hooks.server.js
import * as main from './locales/main.loader.server.svelte.js'
import * as js from './locales/js.loader.server.js'
import { runWithLocale, loadLocales } from 'wuchale/load-utils/server';
import { locales } from './locales/data.js'

// load at server startup
loadLocales(main.key, main.loadIDs, main.loadCatalog, locales)
loadLocales(js.key, js.loadIDs, js.loadCatalog, locales)

/** @type {import('@sveltejs/kit').Handle} */
export const handle = async ({ event, resolve }) => {
    const locale = event.url.searchParams.get('locale') ?? 'en'
    return await runWithLocale(locale, () => resolve(event))
}
```

Now, `loadLocales` loads all catalogs at the server startup and makes them
ready. Then, for each request, `runWithLocale` makes sure that the requests are
isolated and able to access their own catalogs based on the `locale` from the
URL.

:::tip
You can use any [state store](/guides/state) for your locale.
:::

:::note
If you just copy-pasted the above and have enabled SSG (using [`prerender`](https://svelte.dev/docs/kit/page-options#prerender)), you may encounter an error saying something like:

```
Cannot access url.searchParams on a page with prerendering enabled.
```

The error is self-explanatory, so you have to use another [locale state store](/guides/state).
:::

#### Client

Once the page is rendered on the server with the correct locale, the client has
to load the catalogs also making sure that the messages don't change or flicker
once it takes over. The best place to load the catalogs then is the `load`
function in the top most `+layout.{js,ts}` file. But it should only run once
it's in the browser (the server is already handled).

```javascript
// src/routes/+layout.js
import { locales } from '../locales/data.js'
import { browser } from '$app/environment'
import { loadLocale } from 'wuchale/load-utils'
// so that the loaders are registered, only once here
import '../locales/main.loader.svelte.js'
import '../locales/js.loader.svelte.js'

/** @type {import('./$types').LayoutLoad} */
export const load = async ({url}) => {
    const locale = url.searchParams.get('locale') ?? 'en'
    if (browser && locales.includes(locale)) {
        await loadLocale(locale)
    }
}
```

## Default extraction rules

In addition to the [default rules](/guides/rules), this adapter implements
additional restrictions.

### In `script` (`<script>` and `.svelte.js/ts`)

- The string can be in a variable at the top level, and if it is, it is auto wrapped inside `$derived`.
- It should pass the base heuristic from the Vanilla adapter.
- If the value is inside `$inspect()` calls, it is ignored.
- Otherwise, it is extracted.

Examples:

```javascript
// In $derived or functions
const message = 'This is extracted'
const lowercase = $derived('not extracted')

// Force extraction with comment
const forced = $derived(/* @wc-include */ 'force extracted')
```
```svelte
<p title={'Extracted'}>{/* @wc-ignore */ 'Ignore this'}</p>
```

## `<script module>`s and `.svelte.{js,ts}` files

Unlike component code, code inside these places only runs once. If you are only
developing client only apps, this doesn't make much difference.

But if you do SSR, you have to make sure that all translatable text is inside
function definitions and adjust your usage accordingly:

```js
function foo() {
    const msg = 'Here'
}
```

Because with SSR, startup means server startup, and so if you just have top
level definitions or use `$derived` in these places, they will be stuck with
the locale of the first request and subsequent requests with different locales
may see a flicker until the client takes over. But if you put them inside
function definitions, the function gets executed per request and will not have
this problem.

## Configuration Reference

For the main configuration, look in the [configuration reference](/reference/config).

For the common adapter configuration, look in the [common adapter options](/reference/adapter-common/).

:::tip
If you want to avoid extracting top level strings being auto wrapped in `$derived` unless you explicitly wrap them, you can use the provided heuristic as:

```js
// wuchale.config.js

import { adapter as svelte, svelteDefaultHeuristicDerivedReq } from "@wuchale/svelte"
import { defineConfig } from "wuchale"

export default defineConfig({
    // sourceLocale is en by default
    otherLocales: ['es'],
    adapters: {
        main: svelte({
            loader: 'sveltekit', // e.g.
            heuristic: svelteDefaultHeuristicDerivedReq,
        }),
        // ...
    },
    // ...
}
```
:::

This adapter doesn't have additional configuration options.
